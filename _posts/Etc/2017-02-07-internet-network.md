---
layout:   post
title:    "internet-network"
subtitle: "internet-network"
category: Etc
more_posts: posts.md
tags:     Etc
---

# internet-network

<!--more-->
<!-- Table of contents -->
* this unordered seed list will be replaced by the toc
{:toc}

<!-- text -->

## 1. 노드 (Node)와 네트워크의 기본

### 1.1 노드(Node)란?
* **정의:** 네트워크라는 거대한 그물망(지도) 위에 있는 **'지점'**이나 **'교차로'**.
* **역할:** 데이터를 보내거나(송신), 받거나(수신), 전달(중계)하는 모든 장치.
* **종류:**
    * **엔드 노드 (End Node):** PC, 스마트폰, TV 등 데이터의 출발지이자 최종 목적지. (사용자 소유)
    * **중간 노드 (Intermediate Node):** 라우터, 스위치, 국사 장비 등 데이터를 중계하고 경로를 찾아주는 장비.
        * **특징:** 주로 **KT, SKT, LG U+ 등 통신사(ISP)에서 전국 곳곳에 설치하고 관리**함.

### 1.2 IP 주소와 라우팅
* **IP 할당 구조:** IANA(국제) → APNIC(아시아) → KISA(한국) → ISP(통신사) → 사용자.
* **라우팅(Routing):** 데이터가 목적지까지 가는 경로를 찾는 과정.
    * 각 노드(라우터)는 전 세계 지도를 다 가진 것이 아니라, **"이 IP 대역은 저쪽 방향"**이라는 이정표(라우팅 테이블)만 가지고 있음.
    * 통신사 간 연결은 **IX(인터넷 교환 지점)**에서 **BGP 프로토콜**을 통해 이루어짐.

### 1.3 패킷 경로가 매번 다른 이유
* 네트워크는 고정된 철길이 아니라 **유동적인 도로망**.
* **이유:**
    1.  특정 경로의 **트래픽 정체(Congestion)** 회피.
    2.  장비 고장 시 **우회 경로(Fault Tolerance)** 선택.
    3.  라우터의 **부하 분산** 알고리즘 작동.

---

## 2. 패킷 (Packet)

### 2.1 패킷의 구조 (택배 박스 비유)
데이터를 한 번에 보내지 않고 잘게 쪼갠 전송 단위.
1.  **헤더 (Header):** 운송장. (출발지/목적지 IP, 순서 번호, 포트 번호 등 핵심 정보 포함)
2.  **페이로드 (Payload):** 내용물. (실제 데이터 조각)
3.  **트레일러 (Trailer):** 마감재. (에러 검출용 코드, CRC)

---

## 3. TCP/IP 4계층 모델

데이터 전송 시 **캡슐화(포장)**와 **역캡슐화(포장 뜯기)**가 일어나는 과정.

| 계층 | 이름 (Eng) | 역할 및 비유 | 담당 위치 (구현) |
| :--- | :--- | :--- | :--- |
| **1계층** | **응용 계층**<br>(Application) | **내용물 작성**<br>데이터 생성 (HTTP, FTP 등) | **User Space**<br>(브라우저, 카톡 등 프로그램) |
| **2계층** | **전송 계층**<br>(Transport) | **분류 및 번호표**<br>포트 연결, 순서 제어 (TCP/UDP) | **Kernel Space (OS)**<br>(윈도우, 리눅스 커널) |
| **3계층** | **인터넷 계층**<br>(Internet) | **주소지 부착**<br>IP 주소 확인, 경로 설정 | **Kernel Space (OS)**<br>(윈도우, 리눅스 커널) |
| **4계층** | **네트워크 인터페이스**<br>(Network Access) | **배송 차량 탑승**<br>MAC 주소, 전기 신호 변환 | **Hardware**<br>(LAN 카드, 드라이버) |

---

## 4. TCP 3-Way Handshake (연결 과정)

TCP 프로토콜이 신뢰성 있는 통신을 하기 위해 **본격적인 데이터 전송 전에** 수행하는 3단계 인사 과정.

1.  **SYN (똑똑):** 클라이언트가 서버에게 "연결해도 될까요?"라고 요청.
2.  **SYN + ACK (네, 들어오세요):** 서버가 "네, 준비됐습니다. 저도 말 걸어도 되나요?"라고 응답.
3.  **ACK (네, 알겠습니다):** 클라이언트가 "확인했습니다. 이제 데이터 보냅니다."라고 응답.

> **참고:** 매번 이 과정을 거치면 느리기 때문에, **Kafka** 같은 시스템은 한 번 연결해 둔 통로(Persistent Connection)를 계속 재사용하여 속도를 높임.

---

## 5. 시스템 아키텍처: 커널과 I/O

### 5.1 커널 (Kernel)
* **정의:** 운영체제(OS)의 핵심이자 **하드웨어(금고) 관리자**.
* **역할:** 사용자 프로그램(App)이 하드웨어를 직접 건드리지 못하게 보호하며, 요청(System Call)을 받아 대신 처리해줌.
* **메모리 분리:**
    * **User Space:** 프로그램이 동작하는 영역.
    * **Kernel Space:** OS와 드라이버가 동작하는 보안 영역.

### 5.2 일반적인 파일 전송 (Standard I/O) vs Zero Copy

**[상황]** 디스크의 파일을 네트워크로 전송할 때

#### A. 일반 방식 (Standard I/O)
데이터가 **커널 영역과 유저 영역을 넘나들며** 불필요한 복사가 발생함.
* **경로:** Disk → `Kernel Buffer` → `User Buffer(App)` → `Socket Buffer` → NIC
* **비용:**
    * 데이터 복사 4회 발생.
    * **컨텍스트 스위칭(Context Switching)** 4회 발생 (CPU 낭비 심함).
* **Java 코드:** `InputStream.read()` & `OutputStream.write()`

#### B. 제로 카피 (Zero Copy) - Kafka, Nginx의 비결
데이터가 **유저 영역(App)을 거치지 않고** 커널 영역 내에서 바로 전송됨.
* **경로:** Disk → `Kernel Buffer` → (주소값 전달) → `Socket Buffer` → NIC
* **장점:**
    * 데이터 복사 2회로 감소 (CPU가 데이터 이동에 관여 안 함).
    * 컨텍스트 스위칭 2회로 감소.
    * **DMA(Direct Memory Access)** 기술 적극 활용.
* **Java 코드:** `FileChannel.transferTo()`
* **의미:** "응용 계층을 생략한다" = 코드는 응용 계층에서 짜지만, **실제 데이터는 응용 계층 메모리에 올라오지 않고(Bypass) 커널에서 바로 나간다.**