---
layout:   post
title:    "http"
subtitle: "http"
category: Etc
more_posts: posts.md
tags:     Etc
---

# http

<!--more-->
<!-- Table of contents -->
* this unordered seed list will be replaced by the toc
{:toc}

<!-- text -->

# HTTP 구조 및 Stateful vs Stateless 핵심 정리

## 1. HTTP 메시지 구조

HTTP 메시지는 클라이언트의 **요청(Request)**과 서버의 **응답(Response)**으로 나뉘며, 두 메시지 모두 아래와 같은 4가지 핵심 구조를 가진다.

### 기본 구조도
1.  **시작 라인 (Start Line):** 메시지의 핵심 요약 (무엇을 할지, 또는 결과가 어떤지)
2.  **헤더 (Headers):** 메시지의 속성, 데이터 길이, 타입 등 메타 정보
3.  **공백 라인 (Empty Line):** 헤더의 끝을 알리는 필수 공백 (CRLF)
4.  **바디 (Body):** 실제 전송할 데이터 (HTML, JSON 등 / 없으면 생략 가능)

---

## 2. 요청(Request) & 응답(Response) 예시

**상황:** 사용자가 로그인(Login)을 시도하고, 서버가 성공 응답을 보내는 시나리오다.

### (1) 클라이언트 요청 (Request Message)
> `POST` 방식으로 아이디와 비밀번호를 서버로 전송한다.

```http
POST /login HTTP/1.1        <-- 1. 시작 라인 (Request Line)
Host: [www.example.com](https://www.example.com)       <-- 2. 헤더 (Headers)
Content-Type: application/json
Content-Length: 45
                            <-- 3. 공백 라인 (헤더와 바디 구분)
{"id": "user1", "pw": "1234"} <-- 4. 바디 (Message Body)
```

* **시작 라인 분석:**
    * `POST`: HTTP 메서드 (데이터 전송/생성 행위)
    * `/login`: 요청 대상 (Target URL)
    * `HTTP/1.1`: 사용하는 HTTP 버전

### (2) 서버 응답 (Response Message)
> 서버가 요청을 처리한 후, 성공했다는 신호를 보낸다.

```http
HTTP/1.1 200 OK             <-- 1. 시작 라인 (Status Line)
Content-Type: application/json <-- 2. 헤더 (Headers)
Date: Sat, 07 Feb 2026 12:00:00 GMT
Content-Length: 50
                            <-- 3. 공백 라인
{"message": "Login Success", "token": "abcde"} <-- 4. 바디 (Message Body)
```

* **시작 라인 분석:**
    * `HTTP/1.1`: HTTP 버전
    * `200`: 상태 코드 (성공을 의미)
    * `OK`: 상태 문구 (사람이 읽기 위한 설명)

---

## 3. Stateful vs Stateless 차이점

이 두 개념의 핵심 차이는 **"서버가 클라이언트의 이전 상태(문맥)를 기억하느냐"**에 있다.

### (1) Stateless (무상태) - HTTP의 기본 특징
서버가 클라이언트의 이전 요청을 기억하지 않는다. 모든 요청은 독립적이다.

* **특징:** "너 누구야?"를 매번 물어본다. 이전 요청과 관계없이 서버는 현재 요청만 처리하고 잊어버린다.
* **쉬운 예시 (카페):**
    * 손님: "아메리카노 주세요." -> 점원: "네, 결제했습니다." (거래 끝)
    * 손님: "시럽 추가해주세요." -> 점원: "네? 어떤 커피요? 결제 내역 다시 보여주세요." (이전 주문을 모름)
* **장점:** **서버 확장성(Scale-out)**이 좋다. (아무 점원이나 응답해도 상관없다)
* **단점:** 클라이언트가 매번 필요한 정보(토큰, 쿠키 등)를 담아서 보내야 한다.

### (2) Stateful (상태 유지)
서버가 클라이언트의 이전 상태(문맥)를 보존하고 있다.

* **특징:** "아까 그 사람 왔구나"를 안다. 주로 TCP 연결이나 세션 등을 통해 구현된다.
* **쉬운 예시 (전담 헬스 트레이너):**
    * 회원: "오늘은 뭐 할까요?" -> 트레이너: "어제 하체 했으니 오늘은 상체 하시죠." (이전 기록을 기억함)
* **장점:** 클라이언트가 매번 구구절절 설명하지 않아도 문맥이 이어진다.
* **단점:** 서버 하나가 장애가 나면 유지되던 정보가 날아간다. 항상 같은 서버와 통신해야 하므로 확장이 어렵다.

### (3) 요약 비교표

| 구분 | Stateless (무상태) | Stateful (상태 유지) |
| :--- | :--- | :--- |
| **핵심** | 서버는 과거를 기억하지 않음 | 서버가 클라이언트 상태를 기억함 |
| **대표 예시** | **HTTP**, UDP | TCP, 온라인 뱅킹 세션 |
| **서버 확장성** | **유리함** (아무 서버나 처리 가능) | 불리함 (특정 서버에 종속) |
| **데이터 전송** | 매번 많은 데이터 포함 필요 | 최소한의 데이터만 전송 가능 |
| **비유** | 자판기 (누가 뽑든 상관없음) | 전화 통화 (말의 문맥이 이어짐) |

> **참고:** HTTP는 기본적으로 **Stateless**이지만, 우리가 웹사이트에서 로그인을 유지하는 것처럼 보이는 이유는 **쿠키(Cookie)나 세션(Session)** 같은 기술을 사용하여 **Stateful한 것처럼 보완**해서 사용하기 때문이다.