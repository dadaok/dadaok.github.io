---
layout:   post
title:    "Spring Reactive Web Applications: Reactor 1부"
subtitle: "Spring Reactive Web Applications: Reactor 1부"
category: Spring
more_posts: posts.md
tags:     Spring
---
# [Spring-Reactive] 리액티브 시스템과 리액티브 프로그래밍

<!--more-->
<!-- Table of contents -->
* this unordered seed list will be replaced by the toc
{:toc}

<!-- text -->

## 리액티브 시스템이란?
> 변화에 민감하게 반응하고(Responsive), 실패에 강하며(Resilient), 부하에 따라 유연하게 확장되고(Elastic), 메시지 기반(Message Driven)으로 구성된 시스템을 말한다.  
(즉, 안정적이고 유연하며 빠른 응답을 보장하는 현대적인 시스템 설계 방식)

## 리액티브 선언문
> 리액티브 선언문은 이랙티브라는 용어의 의미를 올바르게 정의하기 위해 노력하는 사람들이 만든 리액티브 시스템 구축을 위한 일종의 설계 원칙

![img.png](img.png)

| 항목         |간단 정의|예시 또는 관련 특성|
|------------|---|---|
| VALUE (가치) | 우리가 리액티브 시스템에서 얻고자 하는 최종 목표 | Responsive (응답성) – 빠르고 안정적인 응답|
 | FORM (형식)  | 그 가치를 달성하기 위한 시스템의 구조적 성질 | Elastic (탄력성), Resilient (회복성)|
 | MEANS (수단) | 형식을 구현하기 위한 구체적인 실행 수단 | Message Driven (메시지 기반) 아키텍처|

## 리액티브 프로그래밍의 특징
- `선언형 프로그래밍 방식` : 동작을 어떻게 수행할지를 명령하지 않고, 무엇을 할지만 선언함
  - → 코드가 간결하고 의도를 명확하게 표현

```java
// 명령형(for문을 돌아라, A로 시작되는걸 찾아서 넣어라)
List<String> result = new ArrayList<>();
for(String s : list) {
    if(s.startsWith("A")) result.add(s);
}

// 선언형(A로 시작되는걸 필터링 한다)
List<String> result = list.stream()
        .filter(s -> s.startsWith("A"))
        .toList();
```

- `데이터 스트림(data streams)` : 데이터가 지속적으로 흐름
  - → 시간의 흐름에 따라 발생하는 데이터를 처리

```java
// 예시 : 센서에서 실시간으로 온도가 들어오는 경우, Flux<Integer> 로 1초마다 온도 값 수신
Flux.interval(Duration.ofSeconds(1))
    .map(tick -> getTemperatureFromSensor())
    .subscribe(temp -> System.out.println("현재 온도: " + temp));
```

- `변화의 전파(propagation of change)` : 데이터에 변화가 생기면 자동으로 관련된 연산에 전파
  - → 이벤트 기반 반응 처리 가능

```java
// 예시 : 사용자의 이름이 바뀌면, UI 화면에 자동으로 반영
BehaviorSubject<String> username = BehaviorSubject.createDefault("Alice");

username.subscribe(name -> System.out.println("이름 변경됨: " + name));

username.onNext("Bob"); // onNext를 통해 'Bob' 입력시 '이름 변경됨: Bob' 내용이 자동으로 출력된다.
```

## 리액티브 프로그래밍 코드 구성

| 구성 요소       | 역할 요약|
|-------------|---|
| Publisher   | 데이터를 발행함 (생산자 역할)|
 | Subscriber  | 데이터를 구독하고 소비함 (소비자 역할)|
 | Data Source | Publisher에 입력되는 실제 원천 데이터|
 | Operator    | Publisher → Subscriber 사이에서 데이터 변환/가공|

```java
Flux<Integer> source = Flux.range(1, 5);              // Data Source + Publisher
Flux<Integer> mapped = source.map(i -> i * 10);       // Operator(데이터를 가공: 1 → 10, 2 → 20 ...)
mapped.subscribe(System.out::println);                // Subscriber(가공된 데이터를 소비)
```

## 리액티브 스트림즈란?
> 리액티브 스트림즈는 데이터 스트림을 비동기·논블로킹 방식으로 처리하기 위한 표준이며, RxJava, Reactor(Spring Framework와 궁합이 좋다) 등이 대표 구현체다.

### 리액티브 스트림즈 구성요소 요약
- **Publisher**: 데이터를 생성하고 전달(발행)하는 역할.
- **Subscriber**: Publisher로부터 전달받은 데이터를 처리하는 역할.
- **Subscription**: Subscriber가 요청할 데이터 개수를 지정하고 구독을 취소하는 역할.
- **Processor**: Publisher이면서 Subscriber 역할도 함께 하는 중간 처리자.

**동작 흐름 요약**  
1. Subscriber가 Publisher를 구독(`subscribe`)한다.
2. Publisher가 구독 준비 완료를 알린다(`onSubscribe`).
3. Subscriber가 필요한 데이터 개수를 요청한다(`request`).
4. Publisher가 요청한 만큼 데이터를 전달한다(`onNext`).
5. 데이터가 모두 전달되면 완료를 알린다(`onComplete`), 에러 발생 시(`onError`) 알린다.

#### 리액티브 스트림즈 구성요소 코드 예시

**Publisher**  
- Subscriber를 등록받고 데이터를 발행하는 인터페이스.
```java
public interface Publisher<T> {
    public void subscribe(Subscriber<? super T> s);
}
```

**Subscriber**  
- Publisher가 발행한 데이터를 받아 처리하는 인터페이스.
```java
public interface Subscriber<T> {
    public void onSubscribe(Subscription s); // 구독 시작, Subscription 수신.
    public void onNext(T t); // 데이터 수신.
    public void onError(Throwable t); // 에러 처리.
    public void onComplete(); // 데이터 송신 완료 알림.
}

```

**Subscription**
- 데이터 요청량을 제어하거나 구독을 취소하는 인터페이스.

```java
public interface Subscription {
    public void request(long n);
    public void cancel();
}
```

**통합 예시**  

|컴포넌트 | 역할|
|---|---|
|MyPublisher | 1~5까지 데이터를 발행|
|MyProcessor | 데이터를 10배로 가공|
|MySubscriber | 가공된 데이터를 받아 출력|
|Subscription | 몇 개의 데이터를 받을지 요청하고 관리|


```java
import org.reactivestreams.*;

// 메인 실행 클래스
public class SimpleExample {
    public static void main(String[] args) {
        Publisher<Integer> publisher = new MyPublisher(); // 데이터 만드는 Publisher
        Processor<Integer, Integer> processor = new MyProcessor(); // 중간 가공하는 Processor
        Subscriber<Integer> subscriber = new MySubscriber(); // 최종 소비하는 Subscriber

        publisher.subscribe(processor); // Processor가 Publisher를 구독
        processor.subscribe(subscriber); // Subscriber가 Processor를 구독
    }
}

// 데이터를 발행하는 Publisher
class MyPublisher implements Publisher<Integer> {
    @Override
    public void subscribe(Subscriber<? super Integer> subscriber) {
        // ⭐ Subscription 객체 생성 ⭐
        Subscription subscription = new Subscription() {
            @Override
            public void request(long n) { // 데이터 n개 요청 처리
                for (int i = 1; i <= n; i++) {
                    subscriber.onNext(i); // 데이터 하나씩 발행
                }
                subscriber.onComplete(); // 모든 데이터 발행 후 완료 알림
            }

            @Override
            public void cancel() { // 구독 취소 시 동작
                System.out.println("구독 취소");
            }
        };
        subscriber.onSubscribe(subscription); // ⭐ Subscriber에게 Subscription 전달 (구독 시작 알림) ⭐
    }
}

// 데이터를 가공하는 Processor (Publisher + Subscriber 둘 다 역할)
class MyProcessor implements Processor<Integer, Integer> {
    private Subscriber<? super Integer> downstream; // 다음 Subscriber를 저장

    @Override
    public void subscribe(Subscriber<? super Integer> subscriber) {
        this.downstream = subscriber; // downstream 저장
    }

    @Override
    public void onSubscribe(Subscription subscription) {
        // ⭐ Publisher에게 데이터 5개를 요청 ⭐
        subscription.request(5);
    }

    @Override
    public void onNext(Integer item) {
        downstream.onNext(item * 10); // 받은 데이터 가공 후 downstream에 전달
    }

    @Override
    public void onError(Throwable t) {
        downstream.onError(t); // 에러 전달
    }

    @Override
    public void onComplete() {
        downstream.onComplete(); // 완료 신호 전달
    }
}

// 데이터를 소비하는 Subscriber
class MySubscriber implements Subscriber<Integer> {
    @Override
    public void onSubscribe(Subscription subscription) {
        // ⭐ Processor에게 무한 데이터 요청 (Long.MAX_VALUE) ⭐
        subscription.request(Long.MAX_VALUE);
    }

    @Override
    public void onNext(Integer item) {
        System.out.println("받은 데이터: " + item); // 받은 데이터 출력
    }

    @Override
    public void onError(Throwable t) {
        System.out.println("에러: " + t.getMessage()); // 에러 출력
    }

    @Override
    public void onComplete() {
        System.out.println("완료!"); // 완료 메시지 출력
    }
}

```

**Processor**
- `Subscriber` + `Publisher`를 동시에 구현하는 중간 처리자.

### 리액티브 스트림즈 관련 용어 정의
> 리액티브 스트림즈는 Signal로 소통하고, Demand로 요청하고, Emit으로 발행하며, 데이터는 Upstream → Downstream 방향으로 Sequence를 따라 Operator로 처리(가공)되고, Source(데이터)에서 시작된다.

|용어 | 의미|
|---|---|
|Signal | Publisher와 Subscriber 간에 주고받는 신호 (ex. onNext, onError, onComplete 호출)|
|Demand | Subscriber가 Publisher에게 데이터를 "요청"하는 것 (request 메서드 호출)|
|Emit | Publisher가 데이터를 "발행"해서 Subscriber에게 보내는 것|
|Upstream/Downstream | 데이터 흐름 방향: Upstream(위쪽, 데이터 제공자) → Downstream(아래쪽, 데이터 소비자)|
|Sequence | 데이터의 연속적인 흐름(시퀀스), 연산자 체인으로 이어지는 데이터 흐름|
|Operator | 데이터를 변환하거나 가공하는 메서드들 (ex. map, filter)|
|Source | 데이터의 시작점(원본), ex. Data Source, Source Flux 등|


### 리액티브 스트림즈 구현 규칙
> 요청한 만큼만 안전하게 데이터를 보내고, 실패하거나 끝나면 깨끗하게 정리한다.

#### Publisher 구현 규칙
- 요청한 데이터 수 이하로만 `onNext` 호출해야 한다.
- 데이터 발행 중 실패하면 `onError`, 성공하면 `onComplete` 호출해야 한다.
- 완료(`onComplete`) 또는 에러(`onError`) 후에는 더 이상 Signal을 보내면 안 된다.
- 구독이 취소되면 데이터 발행을 멈춰야 한다.

#### Subscriber 구현 규칙
- 데이터를 받고 싶으면 반드시 `request(n)`를 호출해야 한다.
- `onComplete`나 `onError` 받은 후에는 다른 메서드를 호출하면 안 된다.
- 구독이 끝나면 Subscription을 명확히 취소하거나 정리해야 한다.
- 하나의 Subscriber는 하나의 Subscription만 유지해야 한다.

#### Subscription 구현 규칙
- `request(n)` 호출은 동기적으로 처리해도 된다.
- 구독이 취소되면 `request(n)`이 더 이상 동작하면 안 된다.
- 잘못된 요청(`n <= 0`)은 에러(`onError`)를 보내야 한다.
- 무한 요청(`Long.MAX_VALUE`)도 지원해야 한다 (Unbounded Stream).

#### Processor
- Publisher + Subscriber 규칙을 동시에 지켜야 한다.


## RxJava, Reactor, WebFlux의 관계
> RxJava와 Reactor는 모두 Reactive Streams 표준을 구현한 라이브러리로, 목적은 비슷하지만 주로 사용되는 생태계와 환경이 다르다. Spring WebFlux는 Reactor를 기반으로 동작하며, RxJava와는 직접적인 관계가 없다. 그러나 RxJava를 사용할 수도 있다.

### Reactor
> Reactor는 스프링 팀이 만든 Reactive Streams 구현체로, WebFlux의 핵심 엔진 역할을 한다.
> Reactive Streams 표준을 준수하며, 비동기 데이터 처리와 논블로킹 스트림을 효율적으로 관리한다.
> 
> Reactor의 주요 클래스:
> - Mono: 0~1개의 데이터를 비동기로 처리.
> - Flux: 0~N개의 데이터를 비동기로 처리.
> 
> Reactor는 WebFlux뿐 아니라, 다른 스프링 모듈(예: Spring Data Reactive, Spring Security Reactive)에서도 사용된다.

### Spring WebFlux
> Spring WebFlux는 스프링 프레임워크에서 제공하는 논블로킹(Non-Blocking) 비동기 웹 애플리케이션 개발을 위한 프레임워크이다.
> - Spring MVC와 유사한 역할을 하지만, Reactive Programming을 기반으로 설계되었다.
> - Servlet API 대신 Netty, Undertow 같은 논블로킹 서버를 사용할 수 있다.
> - 내부적으로 Reactor를 기반으로 동작하며, 데이터를 스트림 형태로 처리한다.

### RxJava
> RxJava는 Netflix가 만든 Reactive Programming 라이브러리로, Reactor와 마찬가지로 Reactive Streams 표준을 지원한다.
> - Reactor와 목적은 동일하지만, 다음과 같은 차이점이 있다:
>   - 범용성: RxJava는 스프링 생태계와 독립적으로 사용되며, 다양한 Java 애플리케이션에서 사용 가능하다.
>   - 스프링과의 통합: Reactor는 스프링 프레임워크와 긴밀하게 통합되어 있으며, RxJava보다 스프링 프로젝트에서 더 많이 사용된다.


## 리액티브와 블로킹 방식의 차이 예제
- 블로킹 방식:
    - 요청 A가 들어옴 → 스레드 1이 할당됨.
    - 요청 A가 DB 작업으로 1초 동안 블로킹 → 스레드 1이 대기.
    - 요청 B가 들어옴 → 스레드 2가 할당됨.
    - 스레드 풀의 크기가 고갈되면 새로운 요청은 대기 상태로 들어감.
- 리액티브 방식:
    - 요청 A가 들어옴 → 스레드 1이 할당되어 작업 시작.
    - 요청 A가 DB 작업으로 1초 동안 대기 → 스레드 1은 대기하지 않고 다른 요청 B 처리로 전환.
    - 요청 A의 DB 작업이 완료되면 이벤트가 발생 → 스레드가 다시 작업 재개.

## 리액티브 방식의 장점과 단점
- 장점:
    - 높은 처리량: 소수의 스레드로도 많은 요청 처리 가능.
    - 자원 효율적: 스레드 풀을 무작정 늘리지 않아도 됨.
    - 적합한 사용 사례: 외부 API 호출, DB 액세스 등 I/O 지연이 많은 애플리케이션.
- 단점:
    - 복잡한 디버깅: 콜백 체인과 비동기 코드로 인해 디버깅과 오류 추적이 어렵습니다.
    - 학습 곡선: 기존의 동기식 방식과 비교하여 배우기 더 어려움.
    - 특정 작업에는 부적합: CPU 집약적인 작업(예: 데이터 처리, 복잡한 계산)에는 큰 이점이 없음.