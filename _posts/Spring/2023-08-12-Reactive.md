---
layout:   post
title:    "Spring Reactive Web Applications: Reactor 1부"
subtitle: "Spring Reactive Web Applications: Reactor 1부"
category: Spring
more_posts: posts.md
tags:     Spring
---
# [Spring-Reactive] 리액티브 시스템과 리액티브 프로그래밍

<!--more-->
<!-- Table of contents -->
* this unordered seed list will be replaced by the toc
{:toc}

<!-- text -->

## 리액티브 시스템이란?
> 변화에 민감하게 반응하고(Responsive), 실패에 강하며(Resilient), 부하에 따라 유연하게 확장되고(Elastic), 메시지 기반(Message Driven)으로 구성된 시스템을 말한다.  
(즉, 안정적이고 유연하며 빠른 응답을 보장하는 현대적인 시스템 설계 방식)

## 리액티브 선언문
> 리액티브 선언문은 이랙티브라는 용어의 의미를 올바르게 정의하기 위해 노력하는 사람들이 만든 리액티브 시스템 구축을 위한 일종의 설계 원칙

![img.png](img.png)

| 항목         |간단 정의|예시 또는 관련 특성|
|------------|---|---|
| VALUE (가치) | 우리가 리액티브 시스템에서 얻고자 하는 최종 목표 | Responsive (응답성) – 빠르고 안정적인 응답|
 | FORM (형식)  | 그 가치를 달성하기 위한 시스템의 구조적 성질 | Elastic (탄력성), Resilient (회복성)|
 | MEANS (수단) | 형식을 구현하기 위한 구체적인 실행 수단 | Message Driven (메시지 기반) 아키텍처|

## 리액티브 프로그래밍의 특징
- `선언형 프로그래밍 방식` : 동작을 어떻게 수행할지를 명령하지 않고, 무엇을 할지만 선언함
  - → 코드가 간결하고 의도를 명확하게 표현

```java
// 명령형(for문을 돌아라, A로 시작되는걸 찾아서 넣어라)
List<String> result = new ArrayList<>();
for(String s : list) {
    if(s.startsWith("A")) result.add(s);
}

// 선언형(A로 시작되는걸 필터링 한다)
List<String> result = list.stream()
        .filter(s -> s.startsWith("A"))
        .toList();
```

- `데이터 스트림(data streams)` : 데이터가 지속적으로 흐름
  - → 시간의 흐름에 따라 발생하는 데이터를 처리

```java
// 예시 : 센서에서 실시간으로 온도가 들어오는 경우, Flux<Integer> 로 1초마다 온도 값 수신
Flux.interval(Duration.ofSeconds(1))
    .map(tick -> getTemperatureFromSensor())
    .subscribe(temp -> System.out.println("현재 온도: " + temp));
```

- `변화의 전파(propagation of change)` : 데이터에 변화가 생기면 자동으로 관련된 연산에 전파
  - → 이벤트 기반 반응 처리 가능

```java
// 예시 : 사용자의 이름이 바뀌면, UI 화면에 자동으로 반영
BehaviorSubject<String> username = BehaviorSubject.createDefault("Alice");

username.subscribe(name -> System.out.println("이름 변경됨: " + name));

username.onNext("Bob"); // onNext를 통해 'Bob' 입력시 '이름 변경됨: Bob' 내용이 자동으로 출력된다.
```

## 리액티브 프로그래밍 코드 구성

| 구성 요소       | 역할 요약|
|-------------|---|
| Publisher   | 데이터를 발행함 (생산자 역할)|
 | Subscriber  | 데이터를 구독하고 소비함 (소비자 역할)|
 | Data Source | Publisher에 입력되는 실제 원천 데이터|
 | Operator    | Publisher → Subscriber 사이에서 데이터 변환/가공|

```java
Flux<Integer> source = Flux.range(1, 5);              // Data Source + Publisher
Flux<Integer> mapped = source.map(i -> i * 10);       // Operator(데이터를 가공: 1 → 10, 2 → 20 ...)
mapped.subscribe(System.out::println);                // Subscriber(가공된 데이터를 소비)
```

## 리액티브와 블로킹 방식의 차이 예제
- 블로킹 방식:
  - 요청 A가 들어옴 → 스레드 1이 할당됨.
  - 요청 A가 DB 작업으로 1초 동안 블로킹 → 스레드 1이 대기.
  - 요청 B가 들어옴 → 스레드 2가 할당됨.
  - 스레드 풀의 크기가 고갈되면 새로운 요청은 대기 상태로 들어감.
- 리액티브 방식:
  - 요청 A가 들어옴 → 스레드 1이 할당되어 작업 시작.
  - 요청 A가 DB 작업으로 1초 동안 대기 → 스레드 1은 대기하지 않고 다른 요청 B 처리로 전환.
  - 요청 A의 DB 작업이 완료되면 이벤트가 발생 → 스레드가 다시 작업 재개.

## 리액티브 방식의 장점과 단점
- 장점:
  - 높은 처리량: 소수의 스레드로도 많은 요청 처리 가능.
  - 자원 효율적: 스레드 풀을 무작정 늘리지 않아도 됨.
  - 적합한 사용 사례: 외부 API 호출, DB 액세스 등 I/O 지연이 많은 애플리케이션.
- 단점:
  - 복잡한 디버깅: 콜백 체인과 비동기 코드로 인해 디버깅과 오류 추적이 어렵습니다.
  - 학습 곡선: 기존의 동기식 방식과 비교하여 배우기 더 어려움.
  - 특정 작업에는 부적합: CPU 집약적인 작업(예: 데이터 처리, 복잡한 계산)에는 큰 이점이 없음.

## RxJava, Reactor, WebFlux의 관계
> RxJava와 Reactor는 모두 Reactive Streams 표준을 구현한 라이브러리로, 목적은 비슷하지만 주로 사용되는 생태계와 환경이 다르다. Spring WebFlux는 Reactor를 기반으로 동작하며, RxJava와는 직접적인 관계가 없다. 그러나 RxJava를 사용할 수도 있다.

### Reactor
> Reactor는 스프링 팀이 만든 Reactive Streams 구현체로, WebFlux의 핵심 엔진 역할을 한다.
> Reactive Streams 표준을 준수하며, 비동기 데이터 처리와 논블로킹 스트림을 효율적으로 관리한다.
> 
> Reactor의 주요 클래스:
> - Mono: 0~1개의 데이터를 비동기로 처리.
> - Flux: 0~N개의 데이터를 비동기로 처리.
> 
> Reactor는 WebFlux뿐 아니라, 다른 스프링 모듈(예: Spring Data Reactive, Spring Security Reactive)에서도 사용된다.

### Spring WebFlux
> Spring WebFlux는 스프링 프레임워크에서 제공하는 논블로킹(Non-Blocking) 비동기 웹 애플리케이션 개발을 위한 프레임워크이다.
> - Spring MVC와 유사한 역할을 하지만, Reactive Programming을 기반으로 설계되었다.
> - Servlet API 대신 Netty, Undertow 같은 논블로킹 서버를 사용할 수 있다.
> - 내부적으로 Reactor를 기반으로 동작하며, 데이터를 스트림 형태로 처리한다.

### RxJava
> RxJava는 Netflix가 만든 Reactive Programming 라이브러리로, Reactor와 마찬가지로 Reactive Streams 표준을 지원한다.
> - Reactor와 목적은 동일하지만, 다음과 같은 차이점이 있다:
>   - 범용성: RxJava는 스프링 생태계와 독립적으로 사용되며, 다양한 Java 애플리케이션에서 사용 가능하다.
>   - 스프링과의 통합: Reactor는 스프링 프레임워크와 긴밀하게 통합되어 있으며, RxJava보다 스프링 프로젝트에서 더 많이 사용된다.
